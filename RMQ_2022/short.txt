1. docker run -d --name rabbitmq -e RABBITMQ_DEFAULT_USER=guest -e RABBITMQ_DEFAULT_PASS=guest -p 5672:5672 -p 15672:15672 rabbitmq:3.10-management
   rabbitmq:3.10-management - это rabbitmq:3.10 + WEB-морда  на порту 15672 она же используется для API
   https://habr.com/ru/post/489086/
   
   RMQ - сервис для получения и отправки сообщений (буфер) между отправителями (publisher) и получателями (consumer).
   Исподльзуется, когда отправитель не должен зависеть от работоспособности и скорости раблоты получателей.
   Например, скрипт выполняется раз в секунду и отправляет тысячи сообщений полписанным на разные события получаетлям, но не хочет отвечать за доставку (ретраи, таймауты, ошибки...)
   Чтобы он не зависал, можно отправлять в промежуточное звено - RMQ и спокойно завершать работу.
   Кроме того, получаели могут отписываться и подписываться на разные сообщения, что приведет к постоянному изменению конфигу отправителя.
   Работает по протоколу AMQP - 5672 TCP, подразумевающему сообщения в следующем формате: служебные поля и payload.
   В служеюбных полях могут располагаться, отвечающие за маршрутизацию по очередям:
	- имя обменника (или сразу очереди в случае использования дефолтного обменника) - обязательно.
	- topic - сторка в формате одного или нескольких слов, разеденных точками (напр., notify.sms, notify.sms.email.call, ...)
	- headers - словарь из одного или нескольких значений key-value (напр., size: medium, city: msk ...)
   Основными элеметнами структуры RMQ являются обменники и очереди. Сначала сообщение попадают в облменники, и в соответвтсии с заданными правилами они иду в очереди.
   Получатели подключаются к очередям.
   
2. Типы обменников: дефолтный обменник самый быстрый, но самы негибкий, topic - средний - позволяет маршрутизирость сообщения по очередям по полю topic с использованием * и #,
   header - самый медленный - по полям заголовка. Сообщения можно маршрутищировать и одновременно по topic и по header. Для этого можно пересыалть их из обменника в обменник.
   Есть еще fanout обменник - отправляет сразу в несколько очередей (можно обойтись без него)
   В сообщении могут быть еще доп. параметры, типа delivery mode: durable или transient (сохранять ли сообщения в rabbitmq при остановке контейнера).
   Настройки уже созданнйо очереди менять нельзя, только удалять и пересоздавать. Причем при пересоздании нужно заново создавать все привязки.
   В обменнике задаетсыя одна или несколько очередей и уловияе, по которму в нее попадабт сообщения.
   Несколько условий внутри одного правила означает, что они должны выполниться одновременно.
   Несколько правил в одом обменнике - каждое работает независимо.
   Т.о., можно создать два правила для одно очереди - получим OR.
   Можно создать одно правило с двумя условиями для одной очереди - получим AND.
   Сообщения можно отправлять/получать через htttp-запросы на api.

(AMQP default) - для отправки нужно указать в routing_key имя очереди
### (AMQP default)
POST {{address}}/exchanges/scooter_rent//publish
Authorization: Basic user_provider:user_provider

@address = http://localhost:15672/api
@auth = Authorization: Basic guest:guest

Отправка:
### notify
POST {{address}}/exchanges/%2F/x_topic/publish
Authorization: Basic guest:guest
{
    "properties": {
        "headers": {
            "city": "nsb",
            "order-size": "small"
        }
    },
    "routing_key": "notify.email",
    "payload": "привет от кролика!",
    "payload_encoding": "string"
}

Получить все настройки
###
GET {{address}}/definitions
Authorization: Basic  admin:ADMINadmin

Получить настройки обменников
### 1
# %2F = '/' (название vhost)
GET {{address}}/exchanges
Authorization: Basic  admin:ADMINadmin

Получить настройки очередей
### 1.1
GET {{address}}/queues/%2F/
Authorization: Basic  admin:ADMINadmin

Получить сообщение и очереди
### (AMQP default)
POST {{address}}/queues/scooter_rent/q_users/get
Authorization: Basic user_provider:user_provider

{
	"count": 5,
	"ackmode": "ack_requeue_true",
	"encoding": "auto",
	"truncate": 50000
}

# curl -u guest:guest -i -H "content-type:application/json" -X POST http://127.0.0.1:15672/api/queues/scooter_rent/q_users/get -d'{"count":5,"ackmode": "ack_requeue_true","encoding":"auto","truncate":50000}' 



3. Очередли и обменники содежрат настройки. Напрю, время жизни сообщения в ms, макс. количсетво сообщений, число попыток переотправки, если от получателя пришел reject 
   (при успешной отправке должен прихидить ack), его можно нескокль раз переотправить.
   Кроме того, можно создавать политики и навешивать их на очереди или обменники по регулярному выражению, соответствующему названиям.
   Очередь применяться на каждый объект независимоэ. Т.е., если очередь на общий лимит сообщений в 40 тыс. применена ко всем очередям, то в каждой из них может быть по 40 тыс. сообщений.
   При превышении лимита можно перенаправоять сообщения в отдельную очередт или отбрасывать из начала очереди (дефольное поведение).
   Важные опциональные параметры:
	alternate-exchange - сообщение не подошло ни под одно правило и перенаправляется в заданный обменник
	dead-letter-exchange - сообщение удалено из очереди (напр. TTL или получатель несколько раз его зареджектил) и перенаправляется в заданный обменник
	delivery-limit - число попыток переотправки перед тем, как удалить сообщение из очереди

4. Authentication - подтверждение подлинности личности: логин +  пароль, логин + токен.
   Authorisation - выдача прав в соответствии с матрицей доступа
   VHost - отдельый независимый экземплять инстанса в том же раббите на том же порту
   
   Обновление прав только через перелогинивание. При изменении прав у пользователя он пересоздается, причем нужно перезадавать постоянно пароль.
   Права доступа (set permission):
	- configure - какие объекты пользователь может перенастраивать (обменники, очереди0. Если ограничит (не .*), то не плпавшие объекты будет нельзя
	- Write - в какие обменники может отправлять сообщений
	- Read  - из каких лччередей может читать
   При отсутствии символов в поле configure пользователь не получает доступа к админке и к API, т.о. отправлять сообщения через http не удастся
   
   Topic permission - ограничение, с каким ключом маршрутизвации можно отправлять сообщения. Работает только для обменников типа "topic", хотя админка выдает полный список. Глюк админки.
      Здесь можно задавать права в регулярке на routing-key (Write - с какими ключами можно слать, с какими - нет). Read - тоже такой глюк админки, для протокола AMQP ничего не значит.
      Потому что читать из обменника нельзя, только из очереди.
   
   Теги:
      MGMT - только чтение разрешенных vhosts. Отключать всои подключения через клиент AMQP.
      Policymaker = MHMT+создание политик
      Monitoring - MGMT+просмотр всех vhosts+все подключения
      Impersonator - отправка сообщений от чужого имени (для тестирования работы). У каждого сообщения есть поле UserID. По умолчанию оно пустое.
      Administartor = ВСЕ
      
   Помимо отправики и получения сообщений, права дают возможность создавать обменники и очерелди и связывать их между собой
   Passive=true - проверка на наличие очереди или обменника, без дальнейшего создания
   Есть таблица прав доступа RabbitMQ
   Доступк API = доступ к плагину админки
      
   Порядок проверки прав:
      1. UserID - Прежде всего должен соответствовать логин
      2. Write - Доступ к обменнику
      3. topic write - Доступ к топику
   
   Автоматический импорт настроек:
      Закинуть в Dockerfile иснтрукцию COPY (файла с настрйоками в папку /etc/rabbitmq/definitions) и... (потом не понял)
      
   Best practise по созданию прав пользователям:
      Кадому сервису создается отлдельный пользователь с правами на необходимые очереди
      Также можно создавать пользоватьелей с правами для разынх vhosts (на все очерели в нем)
      
   В домашке будет создать по пользщователю на каждый сервис и длаит права на оьбменники и на очерели

5. TLS соедниение после TCP   
   Клиент запрашивает сертификат, сервер отдает сертификат, согласование алгоритмов шифрования (сервер предлагает)
   X509 - стандарт сертификатов (формат содержимого: публичный ключ, название, почта, страна...)

6. 
   В политиках очередей указаны параметры:
	ha-mode: exactly - создание реплик (all, exactly, список)
	ha-params: 2 - количество реплик
	ha-sync-mode: automatic -  автоматически синхронизироваться с другой нодой при переезде мастера очереди. (Иначе при переезде зеркала не будет, пока не нажеть кнопку)
	mirror-promotion-on-shutdown/failure: в каких переносить ли владельца очереди при stop_app или fail (when-synced, allways)
	queue_master_locator: как искать нового владельца ноды min-master (переносим на ноду, у которой меньше всего очередей во владении), clients-local (перенос на блюжайшую ноду по rtt), random 


      
7. Плагины
      в RMQ есть встроенные плагины
      shovel - переброска сообщение из одного vhost в другой
      federation - вз-е между нодами
      stomp - включает поддержку протокола STOMP
      MQTT 
      delayed exchange

   
8. 
   RPC - remote procedure call
   Можно отправить в сообщении команду reply_to [имя сервера] и сервер, получив сообщение, ответит, в эту очередь
   Если сервера нет - будет приходить таймаут
   
   correlation toekn позволяет сравнить id сообщение и id пришедших ответов в ответ. В многопоточном режиме очень актуален и де факто - стандарт для асинхронных клиентов
   
10. Логирование и мониторинг
      /var/log/rabbitmq
      rabbitmq.conf:
         log.file = [имя файла, строка не обязательна]
         log.file.level = debug
         log.file.rotation.size = 10240 или log.file.rotation.date = $D10
         log.file.rotation.count = 7
         
         
         
         отправка логов в обменник 
         
      log.exchange = true 
      log.exchange.level = debug
      log.exchange.formatter = json
         amq.rabbitmq.log
      
      rabbitmqctl trace_on - все сообещния (из всех очередей) дублируюися в amq.rabbitmq.trace
      
      




   

   
   
   
   